import pygame
import sys
import random
import time

# =========================
#  SETUP
# =========================
pygame.init()
WIDTH, HEIGHT = 400, 600
SCREEN = pygame.display.set_mode((WIDTH, HEIGHT))
pygame.display.set_caption("Flappy Capy üêπ")

CLOCK = pygame.time.Clock()
FONT = pygame.font.SysFont("Arial", 32)

# --- Game variables ---
gravity = 0.5
capy_movement = 0
game_active = True
score = 0.0
high_score = 0.0

# =========================
#  ASSETS
# =========================$
# Background
background_img = pygame.image.load("capy back.png").convert()
background_img = pygame.transform.scale(background_img, (WIDTH, HEIGHT))

# Capybara sprite (visual) and hitbox (old 40x30 size)
capy_img = pygame.image.load("flappy capy.png").convert_alpha()
capy_img = pygame.transform.scale(capy_img, (60, 45))     # visual size
capy_rect = pygame.Rect(0, 0, 40, 30)                     # hitbox
capy_rect.center = (100, HEIGHT // 2)

# =========================
#  SINGLE PILLAR WITH GAP
# =========================
OBSTACLE_WIDTH = 60      # matches previous pipe width
SCROLL_SPEED   = 150     # px/second (uses dt for smooth movement)

# Each obstacle is a dict: {"x": float, "gap_y": int, "gap_size": int, "surf": Surface}
obstacles = []

def make_pillar_surface(gap_y, gap_size):
    """
    Build a pillar surface that fills the entire screen height,
    with a fully transparent gap opening in the middle.
    Uses clipping so no pixels bleed into the gap.
    """
    surf = pygame.Surface((OBSTACLE_WIDTH, HEIGHT), pygame.SRCALPHA)

    # Colors (retro pixel vibe)
    coin_face = (245, 195, 50)
    coin_edge = (180, 115, 30)

    # Compute top/bottom solid sections
    gap_top = max(0, gap_y - gap_size // 2)
    gap_bot = min(HEIGHT, gap_y + gap_size // 2)

    top_rect    = pygame.Rect(0, 0, OBSTACLE_WIDTH, max(0, gap_top))
    bottom_rect = pygame.Rect(0, gap_bot, OBSTACLE_WIDTH, max(0, HEIGHT - gap_bot))

    def draw_section(rect):
        if rect.height <= 0:
            return
        # base fill + outline
        pygame.draw.rect(surf, coin_face, rect)
        # inset outline by 1px to avoid touching the gap edge visually
        inset = rect.inflate(-2, -2)
        if inset.width > 0 and inset.height > 0:
            pygame.draw.rect(surf, coin_edge, inset, width=2)

        # horizontal ‚Äúcoin bands‚Äù (clamped so they don't reach the gap edge)
        band_h = 22
        y = rect.top
        while y < rect.bottom:
            band_y = min(rect.bottom - 5, y + band_h - 2)  # keep away from edge
            if band_y >= rect.top:
                pygame.draw.rect(surf, coin_edge, (rect.left + 3, band_y, OBSTACLE_WIDTH - 6, 3))
            y += band_h

    # Draw using clip to strictly confine pixels to each section
    if top_rect.height > 0:
        surf.set_clip(top_rect)
        draw_section(top_rect)
    if bottom_rect.height > 0:
        surf.set_clip(bottom_rect)
        draw_section(bottom_rect)

    # Reset clip
    surf.set_clip(None)

    # Hard-clear the gap to ensure FULL transparency (belt-and-suspenders)
    gap_rect = pygame.Rect(0, gap_top, OBSTACLE_WIDTH, max(0, gap_bot - gap_top))
    if gap_rect.height > 0:
        surf.fill((0, 0, 0, 0), gap_rect)

    return surf

def spawn_obstacle():
    """Create one pillar with a random gap position/size."""
    gap_size = random.randint(150, 180)                 # difficulty range
    margin   = 100                                      # keep gap away from extreme edges
    gap_y    = random.randint(margin, HEIGHT - margin)
    obstacles.append({
        "x": WIDTH + 80,                                # start off right edge
        "gap_y": gap_y,
        "gap_size": gap_size,
        "surf": make_pillar_surface(gap_y, gap_size),
    })

def update_obstacles(dt):
    """Move obstacles left and cull off-screen ones."""
    alive = []
    for ob in obstacles:
        ob["x"] -= SCROLL_SPEED * dt
        if ob["x"] + OBSTACLE_WIDTH > -50:
            alive.append(ob)
    return alive

def draw_obstacles():
    for ob in obstacles:
        SCREEN.blit(ob["surf"], (int(ob["x"]), 0))

def obstacle_hitboxes(ob):
    """Return top/bottom rects for collision (aligned to current x)."""
    x = int(ob["x"])
    gap_y = ob["gap_y"]
    gap_size = ob["gap_size"]
    top_rect    = pygame.Rect(x, 0, OBSTACLE_WIDTH, gap_y - gap_size // 2)
    bottom_rect = pygame.Rect(x, gap_y + gap_size // 2, OBSTACLE_WIDTH, HEIGHT - (gap_y + gap_size // 2))
    return top_rect, bottom_rect

def check_collision_single_column():
    # obstacles
    for ob in obstacles:
        r1, r2 = obstacle_hitboxes(ob)
        if capy_rect.colliderect(r1) or capy_rect.colliderect(r2):
            return False
    # bounds
    if capy_rect.top <= -50 or capy_rect.bottom >= HEIGHT:
        return False
    return True

# Spawn timer (reuse your existing cadence)
SPAWNPIPE = pygame.USEREVENT
pygame.time.set_timer(SPAWNPIPE, 1200)  # every 1.2s

# =========================
#  SCORE
# =========================
def score_display(game_state):
    if game_state == "main":
        s = FONT.render(f"Score: {int(score)}", True, (255, 255, 255))
        SCREEN.blit(s, (10, 10))
    else:
        s  = FONT.render(f"Score: {int(score)}", True, (255, 255, 255))
        hs = FONT.render(f"High Score: {int(high_score)}", True, (255, 255, 255))
        SCREEN.blit(s,  (WIDTH // 2 - s.get_width() // 2,  HEIGHT // 2 - 30))
        SCREEN.blit(hs, (WIDTH // 2 - hs.get_width() // 2, HEIGHT // 2 + 10))

# =========================
#  MAIN LOOP
# =========================
last_time = time.perf_counter()

while True:
    now = time.perf_counter()
    dt = now - last_time
    last_time = now

    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            pygame.quit()
            sys.exit()

        if event.type == pygame.KEYDOWN:
            if event.key == pygame.K_SPACE and game_active:
                capy_movement = 0
                capy_movement -= 10
            if event.key == pygame.K_SPACE and not game_active:
                # restart
                game_active = True
                obstacles.clear()
                capy_rect.center = (100, HEIGHT // 2)
                capy_movement = 0
                score = 0.0

        if event.type == SPAWNPIPE and game_active:
            spawn_obstacle()

    # Background
    SCREEN.blit(background_img, (0, 0))

    if game_active:
        # Capy physics
        capy_movement += gravity
        capy_rect.centery += capy_movement

        # Tilted capy draw (based on velocity)
        capy_angle = -capy_movement * 3
        capy_rotated = pygame.transform.rotate(capy_img, capy_angle)
        capy_rotated_rect = capy_rotated.get_rect(center=capy_rect.center)
        SCREEN.blit(capy_rotated, capy_rotated_rect)

        # Obstacles
        obstacles[:] = update_obstacles(dt)
        draw_obstacles()

        # Collisions
        game_active = check_collision_single_column()

        # Score
        score += dt * 60 * 0.01  # similar pace to your original
        score_display("main")

    else:
        if score > high_score:
            high_score = score
        score_display("game_over")

    pygame.display.update()
    CLOCK.tick(60)
